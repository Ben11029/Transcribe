<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§˜å®æ—¶ä½›æ•™è¯­éŸ³ğŸ™è½¬å½•ä¸ç¿»è¯‘ğŸ‰ Pro</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .status-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        tr:last-child td { border-bottom: none; }
        .editable-cell {
            cursor: text;
            background-color: #f8fafc; /* slate-50 */
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 4px;
            padding: 2px 4px;
            margin: -3px -5px; /* Negative margin to fill the cell padding */
        }
        .editable-cell:focus {
            outline: none;
            background-color: white;
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        .highlight {
            color: #dc2626; /* red-600 */
            font-weight: 500;
        }
        .results-text p:not(:last-child) {
            margin-bottom: 0.75rem; /* 12px */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">
    <div class="w-[95vw] max-w-none mx-auto p-6 md:p-8 bg-white rounded-2xl shadow-2xl flex flex-col" style="height: 90vh;">

        <div class="flex-shrink-0">
            <div class="text-center mb-4">
                <h1 class="text-3xl font-bold text-gray-900">ğŸ§˜å®æ—¶ä½›æ•™è¯­éŸ³ğŸ™è½¬å½•ä¸ç¿»è¯‘ğŸ‰ Pro</h1>
                <p class="text-gray-500 mt-2">å¯åŠ¨ä¼šè¯å‰ï¼Œè¯·å…ˆç‚¹å‡»â€œè®¾ç½®â€å¹¶è¾“å…¥è®¿é—®ç ï¼ˆä»…éœ€é¦–æ¬¡è¾“å…¥ï¼‰ï¼Œåå¡«å…¥ä¸ªäººæœ‰æ•ˆä»˜è´¹apiï¼ˆéœ€æ¯æ¬¡é‡å¤è¾“å…¥ï¼‰ï¼Œå†è¿›è¡Œä½¿ç”¨ã€‚ï¼ˆå†…éƒ¨æµ‹è¯•ç‰ˆï¼Œè¯·å‹¿å¤–ä¼ ï¼ğŸ‘€ã€‚ï¼‰</p>
                <p class="text-green-500 mt-2">å¯åŠ¨ä¼šè¯åï¼ŒæŒ‰ <kbd class="px-2 py-1.5 text-xs font-semibold text-green-800 bg-gray-100 border border-gray-200 rounded-lg">F9</kbd> é”®ï¼Œæˆ–ç‚¹å‡»ã€æˆªæ–­âœ‚ï¸Cutã€‘æŒ‰é’®ï¼Œåˆ†å‰²éŸ³é¢‘ç‰‡æ®µã€‚</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-4 gap-2 items-end mb-4">
                <button id="settingsBtn" class="w-full bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all flex items-center justify-center gap-2">
                    è®¾ç½®âš™ï¸Setting
                </button>
                <button id="sessionBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all" disabled>
                    å¯åŠ¨ä¼šè¯â¯ï¸Launch Audio
                </button>
                <button id="pauseBtn" class="w-full bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 focus:outline-none focus:ring-4 focus:ring-yellow-300 transition-all" disabled>
                    æš‚åœâ¸ï¸Pause
                </button>
                <button id="captureBtn" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all" disabled>
                    æˆªæ–­âœ‚ï¸Cut (F9)
                </button>
            </div>

            <div id="status-container" class="h-6 flex items-center mb-4">
                 <div class="flex items-center text-sm font-medium text-gray-600">
                     <div id="status-indicator" class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                     <span id="status-text">ä¼šè¯æœªå¼€å§‹ Audio not started</span>
                </div>
            </div>
        </div>

        <div class="flex-grow bg-slate-50 rounded-lg border border-gray-200 overflow-hidden flex flex-col">
            <div class="overflow-y-auto custom-scrollbar flex-grow">
                <table class="min-w-full">
                    <thead class="bg-slate-100 sticky top-0 z-10">
                        <tr>
                            <th scope="col" class="py-1 px-2 text-left text-xl font-bold text-slate-900 tracking-wider" style="width: 5%;">æ—¶é—´æˆ³</th>
                            <th scope="col" class="py-1 px-2 text-left text-xl font-bold text-slate-900 tracking-wider" style="width: 15%;">è½¬å½•</th>
                            <th scope="col" class="py-1 px-2 text-left text-xl font-bold text-slate-900 tracking-wider" style="width: 30%;">æ ¡æ­£</th>
                            <th scope="col" class="py-1 px-2 text-left text-xl font-bold text-slate-900 tracking-wider" style="width: 50%;">ç¿»è¯‘ en</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody" class="bg-white divide-y divide-gray-200">
                        </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="settingsModalOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl shadow-xl p-8 w-full max-w-6xl m-4">
            <div class="flex justify-between items-center mb-6">
                <h2 class="w-1/2 mx-auto text-2xl font-bold text-gray-900">ã€ä½¿ç”¨è¯´æ˜ä¸è®¾ç½® Instructions and Settingsã€‘</h2>
                <button id="closeSettingsBtn" class="text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
            <div class="space-y-6">
                <div id="accessCodeSection">
                    <h3 class="text-lg font-semibold mb-2 text-gray-800 border-b pb-2">ã€è®¿é—®æƒé™ Access Permissionã€‘</h3>
                    <div class="pt-4 space-y-2">
                        <div>
                            <label for="accessCodeInput" class="block text-sm font-medium text-gray-700 mb-1">è®¿é—®ç  Access Code ï¼ˆä¸€èˆ¬åªéœ€è¦é¦–æ¬¡è¾“å…¥ First time needed onlyï¼‰</label>
                            <input type="password" id="accessCodeInput" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500" placeholder="è¯·è¾“å…¥è®¿é—®ç ä»¥è§£é”åº”ç”¨ Please enter the access code to unlock the application.">
                        </div>
                        <p id="accessCodeError" class="text-sm text-red-600 hidden">è®¿é—®ç é”™è¯¯ï¼Œè¯·é‡è¯•ã€‚The access code is incorrect. Please try again.</p>
                        <button id="unlockBtn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">è§£é” Unlock</button>
                    </div>
                </div>

                <div id="apiModelSettings" class="hidden">
                     <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-800 border-b pb-2">ã€A.ä½¿ç”¨è¯´æ˜ Instructionsã€‘</h3>
                        <p class="text-gray-500 mt-2"><b>1.ğŸ”‘API å¯†é’¥é…ç½®ï¼š</b>è¿›å…¥è®¾ç½®åï¼Œæ‚¨éœ€è¦è‡ªè¡Œè·å– API å¯†é’¥ã€‚é’ˆå¯¹ä¸åŒçš„æœåŠ¡æä¾›å•†ï¼Œè¯·æŸ¥é˜…å…¶å®˜æ–¹æ–‡æ¡£ä»¥è·å–è¯¦ç»†çš„ API å¯†é’¥æŸ¥è¯¢ä¸æ“ä½œæŒ‡å—ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œé…ç½® OpenAI çš„ API å¯†é’¥è¶³ä»¥æ”¯æŒç³»ç»Ÿçš„åŸºæœ¬è¿è¡Œã€‚ç„¶è€Œï¼Œç»è¿‡å†…éƒ¨æµ‹è¯•ï¼Œæˆ‘ä»¬å¼ºçƒˆå»ºè®®æ‚¨åŒæ—¶è·å– Gemini çš„ API å¯†é’¥ï¼Œå› ä¸º Gemini åœ¨åç»­å¤„ç†æ–¹é¢è¡¨ç°å‡ºæ›´é«˜çº§ã€æ›´å‡ºè‰²çš„æ€§èƒ½ã€‚Gemini æä¾›å…è´¹é¢åº¦ ğŸï¼Œå¦‚éœ€æ›´é«˜çº§çš„åŠŸèƒ½æˆ–æ›´å¤§çš„ä½¿ç”¨é‡ï¼Œæ‚¨å¯ä»¥ç»‘å®šæ”¯ä»˜æ–¹å¼è¿›è¡Œå‡çº§ã€‚</p>
                        <p class="text-gray-500 mt-2"><b>2.ğŸ™ï¸ä¼šè¯ç¨³å®šæ€§ä¸éŸ³é¢‘æˆªå–ï¼š</b>æ³¨æ„ä¿æŒå£°æºæ¸…æ™°å¹²å‡€ï¼Œé¿å…å¤šå£°æºã€‚æ”¯æŒéº¦å…‹é£å£°æºï¼Œä¸æ”¯æŒç³»ç»Ÿå†…éƒ¨å£°æºï¼Œæ•…ä¸€èˆ¬å¯ä»¥ç»™ç°åœºä¼šè®®æˆ–è€…å¯¹å¤–éƒ¨æ’­æ”¾æºçš„è½¬å½•ç¿»è¯‘ã€‚æ ¹æ®æµ‹è¯•ï¼Œä¼šè¯å¯åŠ¨åçš„å‰ä¸€åˆ°ä¸¤æ®µå¯èƒ½ä¼šå‡ºç°ä¸ç¨³å®šæƒ…å†µã€‚ä¸ºç¡®ä¿æœ€ä½³ä½“éªŒï¼Œå»ºè®®æ‚¨æå‰æˆªå–ä¸¤æ®µæµ‹è¯•éŸ³é¢‘ ğŸ”‡ï¼Œä¹‹åä¼šé€æ¸è¶‹äºç¨³å®šã€‚åœ¨å¯¹è¯è¿‡ç¨‹ä¸­ï¼Œè¯·å°½é‡é€‰æ‹©åœ¨ä¸€æ®µå®Œæ•´ã€è¿è´¯çš„æ„ç¾¤åœé¡¿å¤„è¿›è¡Œæˆªå–ã€‚é€šå¸¸å»ºè®®å°†æ¯æ®µéŸ³é¢‘æˆªå–ä¸º 3 åˆ° 4 å¥è¯ï¼Œè¿™æ ·æ›´é€‚åˆé¡µé¢æ˜¾ç¤ºï¼Œæå‡ç”¨æˆ·ä½“éªŒ âœ¨ã€‚</p>
                        <p class="text-gray-500 mt-2"><b>3.âœï¸è½¬å½•åçš„ç¼–è¾‘ä¸ä¿®æ”¹ï¼š</b>åœ¨å®Œæˆé¦–æ¬¡è½¬å½•åï¼Œç³»ç»Ÿä¼šæä¾›ç¼–è¾‘ä¿®æ”¹åŠŸèƒ½ã€‚æ‚¨å¯ä»¥æ ¹æ®å®é™…å¬å†™å°è±¡ï¼Œå¯¹å…³é”®å†…å®¹è¿›è¡Œä¿®æ”¹ï¼Œä»¥æé«˜è½¬å½•ç»“æœçš„å‡†ç¡®æ€§ã€‚è¯·æ³¨æ„ï¼Œç³»ç»Ÿç›®å‰åªæä¾›ä¸€æ¬¡ä¿®æ”¹æœºä¼š âš ï¸ï¼Œä¸€æ—¦æ‚¨é€€å‡ºå¯¹è¯æ¡†æˆ–ç¡®è®¤ä¿®æ”¹åï¼Œå°†æ— æ³•å†æ¬¡è¿›è¡Œç¼–è¾‘ã€‚åœ¨æ‚¨è¿›è¡Œä¿®æ”¹æ“ä½œæ—¶ï¼Œå½•éŸ³å°†æŒç»­è¿›è¡Œ ğŸ”„ï¼Œæ‚¨å¯ä»¥åœ¨å®Œæˆä¿®æ”¹å·¥ä½œåï¼Œæ ¹æ®æ—¶æœºæˆªå–ä¸‹ä¸€æ®µéŸ³é¢‘ã€‚</p>
                        <p class="text-gray-500 mt-2"><b>4.â¯ï¸å½•éŸ³æš‚åœä¸æ¢å¤ï¼š</b>åœ¨ä¸ä½¿ç”¨å½•éŸ³åŠŸèƒ½æ—¶ï¼Œæ‚¨å¯ä»¥é€‰æ‹©æš‚åœå½•éŸ³ã€‚æš‚åœåï¼Œæ‚¨å¯ä»¥éšæ—¶æ–¹ä¾¿åœ°é‡æ–°å¼€å§‹å½•éŸ³ï¼Œæ— éœ€ä»å¤´è®¾ç½®ã€‚</p>
                      
                        <h3 class="text-lg font-semibold mb-2 text-gray-800 border-b pb-2 mt-6">ã€B. API å¯†é’¥ Keyã€‘</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4">
                            <div>
                                <label for="openaiApiKey" class="block text-base font-medium text-gray-700 mb-1"><b>OpenAI API å¯†é’¥</b></label>
                                <input type="password" id="openaiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="ç”¨äºè½¬å½•å’Œåç»­å¤„ç† For transcribing and subsequent process.">
                            </div>
                            <div>
                                <label for="geminiApiKey" class="block text-base font-medium text-gray-700 mb-1"><b>Gemini API å¯†é’¥</b></label>
                                <input type="password" id="geminiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" placeholder="ä¸“ç”¨äºåç»­æ–‡æœ¬æ ¡æ­£ä¸ç¿»è¯‘å¤„ç† Only for proofreading and translation.">
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-800 border-b pb-2 mt-6">ã€C. æ¨¡å‹é€‰æ‹© Select Modelsã€‘<p class="text-sm text-gray-500 font-medium inline-block">ï¼ˆä¸€èˆ¬é€‰æ‹©é»˜è®¤å³å¯ï¼‰</p></h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4">
                            <div>
                                <label for="transcriptionModelSelect" class="block text-base font-medium text-gray-700 mb-1"><b>è½¬å½•æ¨¡å‹ Transcribing Models</b></label>
                                 <select id="transcriptionModelSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                                    <option value="gpt-4o-mini-transcribe">GPT-4o-mini-transcribe (é»˜è®¤)</option>
                                    <option value="whisper-1">Whisper-1ï¼ˆæ€»ä½“éƒ½æ¯”4o-mini-transcribeå·®ï¼‰</option>
                                </select>
                            </div>
                            <div>
                                <label for="processingEngineSelect" class="block text-base font-medium text-gray-700 mb-1"><b>å¤„ç†å¼•æ“ Processing Models</b></label>
                                 <select id="processingEngineSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                                     <option value="gpt-4o-mini">OpenAI GPT-4o mini (é»˜è®¤)</option>
                                     <option value="gpt-4o">OpenAI GPT-4oï¼ˆè´µä¸€äº›ï¼Œæ•ˆæœæ›´å¥½ï¼‰</option>
                                     <option value="gemini-2.5-flash">Gemini 2.5 Flashï¼ˆæ¯”Openaiä¾¿å®œï¼Œæ•ˆæœæ›´å¥½ï¼Œæœ‰å…è´¹é¢åº¦ï¼‰</option>
                                     <option value="gemini-2.5-pro">Gemini 2.5 Proï¼ˆæ¯”Flashè´µä¸€å€ï¼Œæ›´å¥½ï¼‰</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Access Code (Should be set via environment variable in production) ---

        // --- DOM Element References ---
        const openaiApiKeyInput = document.getElementById('openaiApiKey');
        const geminiApiKeyInput = document.getElementById('geminiApiKey');
        const transcriptionModelSelect = document.getElementById('transcriptionModelSelect');
        const processingEngineSelect = document.getElementById('processingEngineSelect');
        const sessionBtn = document.getElementById('sessionBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const captureBtn = document.getElementById('captureBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModalOverlay = document.getElementById('settingsModalOverlay');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const accessCodeSection = document.getElementById('accessCodeSection');
        const apiModelSettings = document.getElementById('apiModelSettings');
        const accessCodeInput = document.getElementById('accessCodeInput');
        const unlockBtn = document.getElementById('unlockBtn');
        const accessCodeError = document.getElementById('accessCodeError');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const tableContainer = resultsTableBody.parentElement.parentElement;

        // --- State Management ---
        let mediaRecorder, audioChunks = [], isSessionActive = false, isPaused = false, stream, segmentCounter = 0;

        // --- Event Listeners ---
        sessionBtn.addEventListener('click', toggleSession);
        pauseBtn.addEventListener('click', togglePause);
        captureBtn.addEventListener('click', captureAndProcessSegment);
        settingsBtn.addEventListener('click', () => settingsModalOverlay.classList.remove('hidden'));
        closeSettingsBtn.addEventListener('click', () => settingsModalOverlay.classList.add('hidden'));
        unlockBtn.addEventListener('click', handleUnlock);
        settingsModalOverlay.addEventListener('click', (e) => {
            if (e.target === settingsModalOverlay) settingsModalOverlay.classList.add('hidden');
        });
        window.addEventListener('keydown', handleKeyDown);
        document.addEventListener('DOMContentLoaded', checkAccess);

        // --- Access Control ---
        function checkAccess() {
            if (localStorage.getItem('accessGranted') === 'true') {
                unlockApp();
            } else {
                lockApp();
            }
        }

        // !! MODIFIED FUNCTION !!
        // This function now calls the serverless API to verify the access code.
        async function handleUnlock() {
            const userCode = accessCodeInput.value;
            if (!userCode) {
                accessCodeError.textContent = 'è¯·è¾“å…¥è®¿é—®ç ã€‚Please enter code.';
                accessCodeError.classList.remove('hidden');
                return;
            }

            unlockBtn.disabled = true; // Prevent multiple clicks
            unlockBtn.textContent = 'éªŒè¯ä¸­...';
            accessCodeError.classList.add('hidden');

            try {
                // Send a POST request to our Serverless Function
                const response = await fetch('/api/verify-code', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ accessCode: userCode }), // Send user's code as JSON
                });

                // Parse the JSON response from the server
                const result = await response.json();

                if (response.ok && result.success) {
                    // If the server returns success
                    localStorage.setItem('accessGranted', 'true');
                    unlockApp();
                    // On successful validation, close the settings modal
                    settingsModalOverlay.classList.add('hidden');
                } else {
                    // If the server returns an error
                    accessCodeError.textContent = result.message || 'è®¿é—®ç é”™è¯¯ï¼Œè¯·é‡è¯•ã€‚Wrong!';
                    accessCodeError.classList.remove('hidden');
                }
            } catch (error) {
                // Handle network errors or other exceptions
                console.error('Verification request failed:', error);
                accessCodeError.textContent = 'éªŒè¯è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚';
                accessCodeError.classList.remove('hidden');
            } finally {
                // Restore the button state regardless of success or failure
                unlockBtn.disabled = false;
                unlockBtn.textContent = 'è§£é” Unlock';
            }
        }

        

        function lockApp() {
            sessionBtn.disabled = true;
            pauseBtn.disabled = true;
            captureBtn.disabled = true;
            accessCodeSection.classList.remove('hidden');
            apiModelSettings.classList.add('hidden');
        }

        function unlockApp() {
            sessionBtn.disabled = false;
            accessCodeSection.classList.add('hidden');
            apiModelSettings.classList.remove('hidden');
        }


        // --- Core Functions ---
        function toggleSession() {
            if (isSessionActive) stopSession();
            else startSession();
        }

        async function startSession() {
            if (localStorage.getItem('accessGranted') !== 'true') {
                updateStatus('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¾“å…¥è®¿é—®ç ', 'error');
                return;
            }
            if (!openaiApiKeyInput.value.trim()) {
                updateStatus('è¯·è¾“å…¥ OpenAI API å¯†é’¥ (ç”¨äºè½¬å½•)', 'error');
                return;
            }
            const engine = processingEngineSelect.value;
            if (engine.startsWith('gemini') && !geminiApiKeyInput.value.trim()) {
                updateStatus('è¯·ä¸ºæ‰€é€‰çš„ Gemini å¼•æ“è¾“å…¥ API å¯†é’¥', 'error');
                return;
            }
            if (engine.startsWith('gpt') && !openaiApiKeyInput.value.trim()) {
                updateStatus('è¯·ä¸ºæ‰€é€‰çš„ OpenAI å¼•æ“è¾“å…¥ API å¯†é’¥', 'error');
                return;
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isSessionActive = true;
                isPaused = false;
                updateSessionUI(true);
                startNewRecorder();
                updateStatus('æ­£åœ¨å½•éŸ³... æŒ‰ F9 æˆªå– Recording in progress... Press F9 to capture.', 'recording');
            } catch (err) {
                updateStatus(`æ— æ³•è®¿é—®éº¦å…‹é£: ${err.message}`, 'error');
                isSessionActive = false;
            }
        }

        function stopSession() {
            if (!isSessionActive) return;
            isSessionActive = false;
            isPaused = false;
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.onstop = null;
                mediaRecorder.stop();
            }
            if (stream) stream.getTracks().forEach(track => track.stop());
            updateSessionUI(false);
            updateStatus('ä¼šè¯å·²åœæ­¢ Audio stopped.', 'info');
        }

        function togglePause() {
            if (!isSessionActive) return;
            isPaused = !isPaused;
            if (isPaused) {
                mediaRecorder.pause();
                pauseBtn.textContent = 'ç»§ç»­â¯ï¸Continue';
                captureBtn.disabled = true;
                updateStatus('å·²æš‚åœ Paused', 'paused');
            } else {
                mediaRecorder.resume();
                pauseBtn.textContent = 'æš‚åœâ¸ï¸Pause';
                captureBtn.disabled = false;
                updateStatus('æ­£åœ¨å½•éŸ³... æŒ‰ F9 æˆªå– Recording in progress... Press F9 to capture.', 'recording');
            }
        }

        function handleKeyDown(event) {
            if (event.key === 'F9' && isSessionActive && !isPaused) {
                event.preventDefault();
                captureAndProcessSegment();
            }
        }

        function captureAndProcessSegment() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
            segmentCounter++;
            addPlaceholderRow(`segment-${segmentCounter}`);
            mediaRecorder.stop();
        }

        function startNewRecorder() {
            if (!stream || !isSessionActive) return;
            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                if (audioBlob.size > 0 && segmentCounter > 0) {
                    transcribeAudio(audioBlob, `segment-${segmentCounter}`);
                }
                if (isSessionActive) {
                    startNewRecorder();
                    if(isPaused) mediaRecorder.pause();
                }
            };
            mediaRecorder.start();
        }

        async function transcribeAudio(audioBlob, segmentId) {
            const apiKey = openaiApiKeyInput.value.trim();
            const model = transcriptionModelSelect.value;
            const formData = new FormData();
            formData.append('file', new File([audioBlob], "recording.webm", { type: "audio/webm" }));
            formData.append('model', model);
            try {
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}` },
                    body: formData
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error?.message || 'æœªçŸ¥ Whisper API é”™è¯¯');

                makeCellEditable(segmentId, data.text);
                correctAndPolishText(data.text, segmentId);
            } catch (error) {
                console.error("Whisper Error:", error);
                updateTableCell(segmentId, 1, `è½¬å½•å¤±è´¥: ${error.message}`, 'error');
                updateTableCell(segmentId, 2, '---', 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }

        async function callLLM(prompt) {
            const model = processingEngineSelect.value;
            if (model.startsWith('gemini')) {
                const apiKey = geminiApiKeyInput.value.trim();
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.candidates || data.candidates.length === 0) {
                     throw new Error(data.error?.message || 'Gemini API è¿”å›æ— æ•ˆå“åº”');
                }
                return data.candidates[0].content.parts[0].text;
            } else { // OpenAI models
                const apiKey = openaiApiKeyInput.value.trim();
                const API_URL = 'https://api.openai.com/v1/chat/completions';
                const payload = {
                    model: model,
                    messages: [{ role: "user", content: prompt }]
                };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.choices || data.choices.length === 0) {
                    throw new Error(data.error?.message || 'OpenAI API è¿”å›æ— æ•ˆå“åº”');
                }
                return data.choices[0].message.content;
            }
        }

        async function correctAndPolishText(originalText, segmentId) {
            const prompt = `ä»¥ä¸‹æ˜¯ä¸€æ®µä½›æ•™è®²åº§çš„è¯­éŸ³è½¬å½•ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é”™åˆ«å­—å’Œè°éŸ³å­—ã€‚è¯·çº æ­£æ‰€æœ‰é”™åˆ«å­—å’Œè°éŸ³å­—ï¼Œä½¿ç”¨ç®€ä½“ï¼Œé€‚å½“åˆ†æ®µï¼Œä½¿æ–‡æœ¬æµç•…ã€å‡†ç¡®ï¼Œå¹¶è¿›è¡Œé€‚å½“çš„åˆ†æ®µã€‚è¯·ç›´æ¥è¿”å›å¤„ç†åçš„æ–‡æœ¬ï¼Œä¸è¦æ·»åŠ ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ ‡ç­¾ã€‚\n\nåŸå§‹æ–‡æœ¬ï¼š\n"${originalText}"`;
            try {
                const polishedText = await callLLM(prompt);
                identifyAndHighlightChineseTerms(polishedText, segmentId);
            } catch (error) {
                console.error("Processing Error:", error);
                updateTableCell(segmentId, 2, `æ ¡æ­£å¤±è´¥: ${error.message}`, 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }

        async function identifyAndHighlightChineseTerms(text, segmentId) {
            const prompt = `ä»ä»¥ä¸‹æ–‡æœ¬ä¸­ï¼Œè¯†åˆ«å‡ºä¸ä½›æ•™ä¿®è¡Œ(ä¿®è¯)ã€å­¦æœ¯ç›¸å…³çš„æœ¯è¯­ã€‚è¯·ä»¥JSONæ•°ç»„çš„æ ¼å¼è¿”å›è¿™äº›è¯è¯­ï¼Œä¾‹å¦‚ï¼š["è¯è¯­ä¸€", "è¯è¯­äºŒ"]ã€‚å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¯·è¿”å›ç©ºæ•°ç»„ []ã€‚\n\næ–‡æœ¬ï¼š\n"${text}"`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = formatAndHighlightText(text, terms);
                updateTableCell(segmentId, 2, highlightedHtml, 'success');
                translateText(text, terms, segmentId);
            } catch (error) {
                console.error("Chinese Term ID Error:", error);
                const formattedText = formatAndHighlightText(text, []);
                updateTableCell(segmentId, 2, formattedText, 'success'); // Show formatted unhighlighted text on error
                translateText(text, [], segmentId); // Proceed without terms
            }
        }

        async function translateText(textToTranslate, chineseTerms, segmentId) {
            const prompt = `è¯·å°†ä»¥ä¸‹ä¸­æ–‡æ–‡æœ¬ç›´æ¥ç¿»è¯‘æˆè‹±æ–‡ï¼Œé€‚å½“åˆ†æ®µã€‚ä¸è¦å›å¤å…¶ä»–å†…å®¹ã€‚\n\nä¸­æ–‡æ–‡æœ¬ï¼š\n"${textToTranslate}"`;
            try {
                const translatedText = await callLLM(prompt);
                identifyAndHighlightEnglishTerms(translatedText, chineseTerms, segmentId);
            } catch (error) {
                console.error("Translation Error:", error);
                updateTableCell(segmentId, 3, `ç¿»è¯‘å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function identifyAndHighlightEnglishTerms(text, chineseTerms, segmentId) {
            if (chineseTerms.length === 0) {
                const formattedText = formatAndHighlightText(text, []);
                updateTableCell(segmentId, 3, formattedText, 'success');
                return;
            }
            const prompt = `From the following English text, identify the academic Buddhist terms that correspond to the concepts in the provided Chinese list. Return the identified English terms as a JSON array, for example: ["Term 1", "Term 2"]. If none are found, return an empty array [].\n\nEnglish Text:\n"${text}"\n\nOriginal Chinese Terms for reference:\n${JSON.stringify(chineseTerms)}`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = formatAndHighlightText(text, terms);
                updateTableCell(segmentId, 3, highlightedHtml, 'success');
            } catch (error) {
                console.error("English Term ID Error:", error);
                const formattedText = formatAndHighlightText(text, []);
                updateTableCell(segmentId, 3, formattedText, 'success'); // Show formatted unhighlighted text on error
            }
        }

        function extractJson(text) {
            const match = text.match(/```json\s*([\s\S]*?)\s*```/);
            if (match && match[1]) {
                return match[1].trim();
            }
            return text.trim();
        }

        function updateSessionUI(isActive) {
            sessionBtn.textContent = isActive ? 'ç»ˆæ­¢â¸ï¸End Audio' : 'å¯åŠ¨ä¼šè¯â¯ï¸Launch Audio';
            sessionBtn.classList.toggle('bg-blue-600', !isActive);
            sessionBtn.classList.toggle('hover:bg-blue-700', !isActive);
            sessionBtn.classList.toggle('bg-red-600', isActive);
            sessionBtn.classList.toggle('hover:bg-red-700', isActive);
            pauseBtn.disabled = !isActive;
            captureBtn.disabled = !isActive;
            pauseBtn.textContent = 'æš‚åœâ¸ï¸Pause';
            settingsBtn.disabled = isActive;
        }

        function updateStatus(text, type = 'info') {
            statusText.textContent = text;
            statusIndicator.className = 'w-3 h-3 rounded-full mr-2';
            switch (type) {
                case 'recording': statusIndicator.classList.add('bg-green-500', 'status-dot'); break;
                case 'paused': statusIndicator.classList.add('bg-yellow-500'); break;
                case 'error': statusIndicator.classList.add('bg-red-500'); break;
                default: statusIndicator.classList.add('bg-gray-400');
            }
        }

        const loadingCellHtml = `<div class="flex items-center text-sm text-gray-500"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>å¤„ç†ä¸­...</div>`;

        function addPlaceholderRow(segmentId) {
            const row = resultsTableBody.insertRow(0);
            row.id = segmentId;
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${new Date().toLocaleTimeString()}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
            `;
            scrollToTop();
        }

        function makeCellEditable(segmentId, text) {
            const row = document.getElementById(segmentId);
            if (!row) return;
            const cell = row.cells[1];

            const div = document.createElement('div');
            div.className = 'editable-cell';
            div.contentEditable = true;
            div.textContent = text;
            div.dataset.originalText = text;

            const finalizeEdit = () => {
                if (div.contentEditable !== 'true') return;

                div.contentEditable = false;
                div.classList.remove('editable-cell');
                document.removeEventListener('mousedown', handleDocumentClick, true);

                const newText = div.textContent;
                const originalText = div.dataset.originalText;

                if (newText !== originalText) {
                    updateTableCell(segmentId, 2, loadingCellHtml, 'loading');
                    updateTableCell(segmentId, 3, loadingCellHtml, 'loading');
                    correctAndPolishText(newText, segmentId);
                }
            };

            const handleDocumentClick = (event) => {
                if (!div.contains(event.target)) {
                    finalizeEdit();
                }
            };

            div.addEventListener('focus', () => {
                setTimeout(() => {
                    document.addEventListener('mousedown', handleDocumentClick, true);
                }, 0);
            });

            div.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    finalizeEdit();
                }
            });

            cell.innerHTML = '';
            cell.appendChild(div);
            div.focus();
        }

        function updateTableCell(segmentId, cellIndex, content, status) {
            const row = document.getElementById(segmentId);
            if (!row || !row.cells[cellIndex]) return;
            const cell = row.cells[cellIndex];

            if (status === 'loading') {
                cell.innerHTML = content;
            } else {
// --- è®¾ç½®å­—ä½“å¤§å° ---text-xs (12px)text-sm ( 14px) text-base (16px) text-lg (å¤§, 18px)text-xl (20px)text-2xl (24px)
                cell.innerHTML = `<div class="text-xl results-text ${status === 'success' ? 'text-gray-900' : 'text-red-600'}">${content}</div>`;
            }
        }

        function formatAndHighlightText(text, terms) {
            if (!text) return '';
            let processedText = text;
            if (terms && terms.length > 0) {
                terms.sort((a, b) => b.length - a.length);
                const regex = new RegExp(`(${terms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'g');
                processedText = processedText.replace(regex, `<span class="highlight">$1</span>`);
            }
            return processedText.split(/\n+/).filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
        }

        function scrollToTop() {
            tableContainer.scrollTop = 0;
        }
    </script>
</body>
</html>
