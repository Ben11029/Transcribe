<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时语音转录与处理工具 (F9快捷键)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .status-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        tr:last-child td { border-bottom: none; }
        .editable-cell {
            cursor: text;
            background-color: #f8fafc; /* slate-50 */
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 4px;
            padding: 2px 4px;
            margin: -3px -5px; /* Negative margin to fill the cell padding */
        }
        .editable-cell:focus {
            outline: none;
            background-color: white;
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        .highlight {
            color: #dc2626; /* red-600 */
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-7xl mx-auto p-6 md:p-8 bg-white rounded-2xl shadow-2xl flex flex-col" style="height: 90vh;">
        
        <div class="flex-shrink-0">
            <div class="text-center mb-4">
                <h1 class="text-3xl font-bold text-gray-900">实时语音转录与处理</h1>
                <p class="text-gray-500 mt-2">启动会话后，按 <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">F9</kbd> 键或点击按钮截取音频片段。</p>
            </div>

            <!-- API Keys & Controls -->
            <div class="flex flex-col gap-4 mb-4">
                <!-- First Row: API Keys -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="openaiApiKey" class="block text-sm font-medium text-gray-700 mb-1">OpenAI API 密钥</label>
                        <input type="password" id="openaiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="用于 Whisper/Transcribe 模型，转录功能。">
                    </div>
                    <div>
                        <label for="geminiApiKey" class="block text-sm font-medium text-gray-700 mb-1">Google API 密钥</label>
                        <input type="password" id="geminiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" placeholder="用于 Gemini 模型，选填，专用于文本校正与翻译。">
                    </div>
                </div>
                <!-- Second Row: Buttons & Selectors -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-2 items-end">
                    <div>
                        <label for="transcriptionModelSelect" class="block text-sm font-medium text-gray-700 mb-1">转录模型</label>
                         <select id="transcriptionModelSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <option value="gpt-4o-mini-transcribe">GPT-4o-mini-transcribe</option>
                            <option value="whisper-1">Whisper-1</option>
                        </select>
                    </div>
                    <div>
                        <label for="processingEngineSelect" class="block text-sm font-medium text-gray-700 mb-1">处理引擎</label>
                         <select id="processingEngineSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                            <option value="gpt-4o-mini">OpenAI GPT-4o mini</option>
                            <option value="gpt-4o">OpenAI GPT-4o</option>
                        </select>
                    </div>
                    <button id="sessionBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all">
                        启动会话
                    </button>
                    <button id="pauseBtn" class="w-full bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 focus:outline-none focus:ring-4 focus:ring-yellow-300 transition-all" disabled>
                        暂停
                    </button>
                    <button id="captureBtn" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all" disabled>
                        截断 (F9)
                    </button>
                </div>
            </div>
            
            <!-- Status Display -->
            <div id="status-container" class="h-6 flex items-center mb-4">
                 <div class="flex items-center text-sm font-medium text-gray-600">
                     <div id="status-indicator" class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                     <span id="status-text">会话未开始</span>
                </div>
            </div>
        </div>

        <!-- Results Table -->
        <div class="flex-grow bg-slate-50 rounded-lg border border-gray-200 overflow-hidden flex flex-col">
            <div class="overflow-y-auto custom-scrollbar flex-grow">
                <table class="min-w-full">
                    <thead class="bg-slate-100 sticky top-0 z-10">
                        <tr>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider w-40">时间戳</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">转录内容</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">校正与润色</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">翻译 (English)</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- Rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const openaiApiKeyInput = document.getElementById('openaiApiKey');
        const geminiApiKeyInput = document.getElementById('geminiApiKey');
        const transcriptionModelSelect = document.getElementById('transcriptionModelSelect');
        const processingEngineSelect = document.getElementById('processingEngineSelect');
        const sessionBtn = document.getElementById('sessionBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const captureBtn = document.getElementById('captureBtn');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const tableContainer = resultsTableBody.parentElement.parentElement;

        // --- State Management ---
        let mediaRecorder, audioChunks = [], isSessionActive = false, isPaused = false, stream, segmentCounter = 0;

        // --- Event Listeners ---
        sessionBtn.addEventListener('click', toggleSession);
        pauseBtn.addEventListener('click', togglePause);
        captureBtn.addEventListener('click', captureAndProcessSegment);
        window.addEventListener('keydown', handleKeyDown);

        // --- Core Functions ---
        function toggleSession() {
            if (isSessionActive) stopSession();
            else startSession();
        }

        async function startSession() {
            // Validate that transcription key is always present
            if (!openaiApiKeyInput.value.trim()) {
                updateStatus('请输入 OpenAI API 密钥 (用于转录)', 'error');
                return;
            }
            // Validate key for the selected processing engine
            const engine = processingEngineSelect.value;
            if (engine.startsWith('gemini') && !geminiApiKeyInput.value.trim()) {
                updateStatus('请为所选的 Gemini 引擎输入 API 密钥', 'error');
                return;
            }
            if (engine.startsWith('gpt') && !openaiApiKeyInput.value.trim()) {
                updateStatus('请为所选的 OpenAI 引擎输入 API 密钥', 'error');
                return;
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isSessionActive = true;
                isPaused = false;
                updateSessionUI(true);
                startNewRecorder();
                updateStatus('正在录音... 按 F9 截取', 'recording');
            } catch (err) {
                updateStatus(`无法访问麦克风: ${err.message}`, 'error');
                isSessionActive = false;
            }
        }

        function stopSession() {
            if (!isSessionActive) return;
            isSessionActive = false;
            isPaused = false;
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.onstop = null;
                mediaRecorder.stop();
            }
            if (stream) stream.getTracks().forEach(track => track.stop());
            updateSessionUI(false);
            updateStatus('会话已停止', 'info');
        }

        function togglePause() {
            if (!isSessionActive) return;
            isPaused = !isPaused;
            if (isPaused) {
                mediaRecorder.pause();
                pauseBtn.textContent = '继续';
                captureBtn.disabled = true;
                updateStatus('已暂停', 'paused');
            } else {
                mediaRecorder.resume();
                pauseBtn.textContent = '暂停';
                captureBtn.disabled = false;
                updateStatus('正在录音... 按 F9 截取', 'recording');
            }
        }

        function handleKeyDown(event) {
            if (event.key === 'F9' && isSessionActive && !isPaused) {
                event.preventDefault();
                captureAndProcessSegment();
            }
        }

        function captureAndProcessSegment() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
            segmentCounter++;
            addPlaceholderRow(`segment-${segmentCounter}`);
            mediaRecorder.stop();
        }

        function startNewRecorder() {
            if (!stream || !isSessionActive) return;
            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                if (audioBlob.size > 0 && segmentCounter > 0) {
                    transcribeAudio(audioBlob, `segment-${segmentCounter}`);
                }
                if (isSessionActive) {
                    startNewRecorder();
                    if(isPaused) mediaRecorder.pause();
                }
            };
            mediaRecorder.start();
        }

        async function transcribeAudio(audioBlob, segmentId) {
            const apiKey = openaiApiKeyInput.value.trim();
            const model = transcriptionModelSelect.value;
            const formData = new FormData();
            formData.append('file', new File([audioBlob], "recording.webm", { type: "audio/webm" }));
            formData.append('model', model);
            try {
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}` },
                    body: formData
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error?.message || '未知 Whisper API 错误');
                
                makeCellEditable(segmentId, data.text);
                correctAndPolishText(data.text, segmentId);
            } catch (error) {
                console.error("Whisper Error:", error);
                updateTableCell(segmentId, 1, `转录失败: ${error.message}`, 'error');
                updateTableCell(segmentId, 2, '---', 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }
        
        async function callLLM(prompt) {
            const model = processingEngineSelect.value;
            if (model.startsWith('gemini')) {
                const apiKey = geminiApiKeyInput.value.trim();
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.candidates || data.candidates.length === 0) {
                     throw new Error(data.error?.message || 'Gemini API 返回无效响应');
                }
                return data.candidates[0].content.parts[0].text;
            } else { // OpenAI models
                const apiKey = openaiApiKeyInput.value.trim();
                const API_URL = 'https://api.openai.com/v1/chat/completions';
                const payload = {
                    model: model,
                    messages: [{ role: "user", content: prompt }]
                };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.choices || data.choices.length === 0) {
                    throw new Error(data.error?.message || 'OpenAI API 返回无效响应');
                }
                return data.choices[0].message.content;
            }
        }

        async function correctAndPolishText(originalText, segmentId) {
            const prompt = `以下是一段佛教讲座的语音转录，其中可能包含错别字和谐音字。请纠正所有错别字和谐音字，使用简体，使文本流畅、准确。不要添加任何额外的解释或标签。\n\n原始文本：\n"${originalText}"`;
            try {
                const polishedText = await callLLM(prompt);
                identifyAndHighlightChineseTerms(polishedText, segmentId);
            } catch (error) {
                console.error("Processing Error:", error);
                updateTableCell(segmentId, 2, `校正失败: ${error.message}`, 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }
        
        async function identifyAndHighlightChineseTerms(text, segmentId) {
            const prompt = `从以下文本中，识别出与佛教修行(修证)相关的词语以及佛教学术术语。请以JSON数组的格式返回这些词语，例如：["词语一", "词语二"]。如果找不到，请返回空数组 []。\n\n文本：\n"${text}"`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = highlightText(text, terms);
                updateTableCell(segmentId, 2, highlightedHtml, 'success');
                translateText(text, terms, segmentId);
            } catch (error) {
                console.error("Chinese Term ID Error:", error);
                updateTableCell(segmentId, 2, text, 'success'); // Show unhighlighted text on error
                translateText(text, [], segmentId); // Proceed without terms
            }
        }

        async function translateText(textToTranslate, chineseTerms, segmentId) {
            const prompt = `请将以下中文文本直接翻译成英文，不要回复其他内容。\n\n中文文本：\n"${textToTranslate}"`;
            try {
                const translatedText = await callLLM(prompt);
                identifyAndHighlightEnglishTerms(translatedText, chineseTerms, segmentId);
            } catch (error) {
                console.error("Translation Error:", error);
                updateTableCell(segmentId, 3, `翻译失败: ${error.message}`, 'error');
            }
        }

        async function identifyAndHighlightEnglishTerms(text, chineseTerms, segmentId) {
            if (chineseTerms.length === 0) {
                updateTableCell(segmentId, 3, text, 'success');
                return;
            }
            const prompt = `From the following English text, identify the academic Buddhist terms that correspond to the concepts in the provided Chinese list. Return the identified English terms as a JSON array, for example: ["Term 1", "Term 2"]. If none are found, return an empty array [].\n\nEnglish Text:\n"${text}"\n\nOriginal Chinese Terms for reference:\n${JSON.stringify(chineseTerms)}`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = highlightText(text, terms);
                updateTableCell(segmentId, 3, highlightedHtml, 'success');
            } catch (error) {
                console.error("English Term ID Error:", error);
                updateTableCell(segmentId, 3, text, 'success'); // Show unhighlighted text on error
            }
        }

        function extractJson(text) {
            const match = text.match(/```json\s*([\s\S]*?)\s*```/);
            if (match && match[1]) {
                return match[1].trim();
            }
            return text.trim();
        }

        function updateSessionUI(isActive) {
            sessionBtn.textContent = isActive ? '停止会话' : '启动会话';
            sessionBtn.classList.toggle('bg-blue-600', !isActive);
            sessionBtn.classList.toggle('hover:bg-blue-700', !isActive);
            sessionBtn.classList.toggle('bg-red-600', isActive);
            sessionBtn.classList.toggle('hover:bg-red-700', isActive);
            pauseBtn.disabled = !isActive;
            captureBtn.disabled = !isActive;
            pauseBtn.textContent = '暂停';
            openaiApiKeyInput.disabled = isActive;
            geminiApiKeyInput.disabled = isActive;
            transcriptionModelSelect.disabled = isActive;
            processingEngineSelect.disabled = isActive;
        }
        
        function updateStatus(text, type = 'info') {
            statusText.textContent = text;
            statusIndicator.className = 'w-3 h-3 rounded-full mr-2';
            switch (type) {
                case 'recording': statusIndicator.classList.add('bg-green-500', 'status-dot'); break;
                case 'paused': statusIndicator.classList.add('bg-yellow-500'); break;
                case 'error': statusIndicator.classList.add('bg-red-500'); break;
                default: statusIndicator.classList.add('bg-gray-400');
            }
        }
        
        const loadingCellHtml = `<div class="flex items-center text-sm text-gray-500"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>处理中...</div>`;

        function addPlaceholderRow(segmentId) {
            const row = resultsTableBody.insertRow(0);
            row.id = segmentId;
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${new Date().toLocaleTimeString()}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
            `;
            scrollToTop();
        }

        function makeCellEditable(segmentId, text) {
            const row = document.getElementById(segmentId);
            if (!row) return;
            const cell = row.cells[1];
            
            const div = document.createElement('div');
            div.className = 'editable-cell';
            div.contentEditable = true;
            div.textContent = text;
            div.dataset.originalText = text;

            const finalizeEdit = () => {
                if (div.contentEditable !== 'true') return;

                div.contentEditable = false;
                div.classList.remove('editable-cell');
                document.removeEventListener('mousedown', handleDocumentClick, true);

                const newText = div.textContent;
                const originalText = div.dataset.originalText;

                if (newText !== originalText) {
                    updateTableCell(segmentId, 2, loadingCellHtml, 'loading');
                    updateTableCell(segmentId, 3, loadingCellHtml, 'loading');
                    correctAndPolishText(newText, segmentId);
                }
            };

            const handleDocumentClick = (event) => {
                if (!div.contains(event.target)) {
                    finalizeEdit();
                }
            };

            div.addEventListener('focus', () => {
                setTimeout(() => {
                    document.addEventListener('mousedown', handleDocumentClick, true);
                }, 0);
            });

            div.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    finalizeEdit();
                }
            });

            cell.innerHTML = '';
            cell.appendChild(div);
            div.focus();
        }

        function updateTableCell(segmentId, cellIndex, content, status) {
            const row = document.getElementById(segmentId);
            if (!row || !row.cells[cellIndex]) return;
            const cell = row.cells[cellIndex];

            if (status === 'loading') {
                cell.innerHTML = content;
            } else {
                cell.innerHTML = `<div class="text-sm ${status === 'success' ? 'text-gray-900' : 'text-red-600'}">${content}</div>`;
            }
        }

        function highlightText(text, terms) {
            if (!terms || terms.length === 0) return text;
            terms.sort((a, b) => b.length - a.length);
            const regex = new RegExp(`(${terms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'g');
            return text.replace(regex, `<span class="highlight">$1</span>`);
        }
        
        function scrollToTop() {
            tableContainer.scrollTop = 0;
        }
    </script>
</body>
</html>
