<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶ä½›æ•™è¯­éŸ³è½¬å½•ä¸ç¿»è¯‘ Pro</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .status-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        tr:last-child td { border-bottom: none; }
        .editable-cell {
            cursor: text;
            background-color: #f8fafc; /* slate-50 */
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 4px;
            padding: 2px 4px;
            margin: -3px -5px; /* Negative margin to fill the cell padding */
        }
        .editable-cell:focus {
            outline: none;
            background-color: white;
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        .highlight {
            color: #dc2626; /* red-600 */
            font-weight: 500;
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-7xl mx-auto p-6 md:p-8 bg-white rounded-2xl shadow-2xl flex flex-col" style="height: 90vh;">
        
        <div class="flex-shrink-0">
            <div class="text-center mb-4">
                <h1 class="text-3xl font-bold text-gray-900">å®æ—¶ä½›æ•™è¯­éŸ³è½¬å½•ä¸ç¿»è¯‘ 2.0 Pro</h1>
                <p class="text-gray-500 mt-2">å¯åŠ¨ä¼šè¯åï¼ŒæŒ‰ <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">F9</kbd> é”®æˆ–ç‚¹å‡»æŒ‰é’®æˆªå–éŸ³é¢‘ç‰‡æ®µã€‚</p>
                <p class="text-gray-400 mt-2">ï¼ˆå†…éƒ¨æµ‹è¯•ç‰ˆï¼ŒæŸæŸäººï¼Œè¯·å‹¿å¤–ä¼ ï¼ğŸ‘€ã€‚ï¼‰</p>
            </div>

            <!-- API Keys & Controls -->
            <div class="flex flex-col gap-4 mb-4">
                <!-- First Row: API Keys -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="openaiApiKey" class="block text-sm font-medium font-weight: bold text-gray-700 mb-1">OpenAI API å¯†é’¥</label>
                        <input type="password" id="openaiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="ç”¨äº Whisper/Transcribe æ¨¡å‹ï¼Œè½¬å½•åŠŸèƒ½ã€‚">
                    </div>
                    <div>
                        <label for="geminiApiKey" class="block text-sm font-medium font-weight: bold text-gray-700 mb-1">Google Gemini API å¯†é’¥</label>
                        <input type="password" id="geminiApiKey" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" placeholder="ç”¨äº Gemini æ¨¡å‹ï¼Œé€‰å¡«ï¼Œä¸“ç”¨äºæ–‡æœ¬æ ¡æ­£ä¸ç¿»è¯‘ã€‚">
                    </div>
                </div>
                <!-- Second Row: Buttons & Selectors -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-2 items-end">
                    <div>
                        <label for="transcriptionModelSelect" class="block text-sm font-medium text-gray-700 mb-1">è½¬å½•æ¨¡å‹</label>
                         <select id="transcriptionModelSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <option value="gpt-4o-mini-transcribe">GPT-4o-mini-transcribe</option>
                            <option value="whisper-1">Whisper-1</option>
                        </select>
                    </div>
                    <div>
                        <label for="processingEngineSelect" class="block text-sm font-medium text-gray-700 mb-1">å¤„ç†å¼•æ“</label>
                         <select id="processingEngineSelect" class="w-full px-4 py-2 bg-gray-100 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                            <option value="gpt-4o-mini">OpenAI GPT-4o mini</option>
                            <option value="gpt-4o">OpenAI GPT-4o</option>
                        </select>
                    </div>
                    <button id="sessionBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all">
                        å¯åŠ¨ä¼šè¯
                    </button>
                    <button id="pauseBtn" class="w-full bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 focus:outline-none focus:ring-4 focus:ring-yellow-300 transition-all" disabled>
                        æš‚åœ
                    </button>
                    <button id="captureBtn" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all" disabled>
                        æˆªæ–­ (F9)
                    </button>
                </div>
            </div>
            
            <!-- Status Display -->
            <div id="status-container" class="h-6 flex items-center mb-4">
                 <div class="flex items-center text-sm font-medium text-gray-600">
                     <div id="status-indicator" class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                     <span id="status-text">ä¼šè¯æœªå¼€å§‹</span>
                </div>
            </div>
        </div>

        <!-- Results Table -->
        <div class="flex-grow bg-slate-50 rounded-lg border border-gray-200 overflow-hidden flex flex-col">
            <div class="overflow-y-auto custom-scrollbar flex-grow">
                <table class="min-w-full">
                    <thead class="bg-slate-100 sticky top-0 z-10">
                        <tr>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider w-40">æ—¶é—´æˆ³</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">è½¬å½•å†…å®¹</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">æ ¡æ­£ä¸æ¶¦è‰²</th>
                            <th scope="col" class="py-3 px-6 text-left text-xs font-medium text-slate-600 uppercase tracking-wider">ç¿»è¯‘ (English)</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- Rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const openaiApiKeyInput = document.getElementById('openaiApiKey');
        const geminiApiKeyInput = document.getElementById('geminiApiKey');
        const transcriptionModelSelect = document.getElementById('transcriptionModelSelect');
        const processingEngineSelect = document.getElementById('processingEngineSelect');
        const sessionBtn = document.getElementById('sessionBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const captureBtn = document.getElementById('captureBtn');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const tableContainer = resultsTableBody.parentElement.parentElement;

        // --- State Management ---
        let mediaRecorder, audioChunks = [], isSessionActive = false, isPaused = false, stream, segmentCounter = 0;

        // --- Event Listeners ---
        sessionBtn.addEventListener('click', toggleSession);
        pauseBtn.addEventListener('click', togglePause);
        captureBtn.addEventListener('click', captureAndProcessSegment);
        window.addEventListener('keydown', handleKeyDown);

        // --- Core Functions ---
        function toggleSession() {
            if (isSessionActive) stopSession();
            else startSession();
        }

        async function startSession() {
            // Validate that transcription key is always present
            if (!openaiApiKeyInput.value.trim()) {
                updateStatus('è¯·è¾“å…¥ OpenAI API å¯†é’¥ (ç”¨äºè½¬å½•)', 'error');
                return;
            }
            // Validate key for the selected processing engine
            const engine = processingEngineSelect.value;
            if (engine.startsWith('gemini') && !geminiApiKeyInput.value.trim()) {
                updateStatus('è¯·ä¸ºæ‰€é€‰çš„ Gemini å¼•æ“è¾“å…¥ API å¯†é’¥', 'error');
                return;
            }
            if (engine.startsWith('gpt') && !openaiApiKeyInput.value.trim()) {
                updateStatus('è¯·ä¸ºæ‰€é€‰çš„ OpenAI å¼•æ“è¾“å…¥ API å¯†é’¥', 'error');
                return;
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isSessionActive = true;
                isPaused = false;
                updateSessionUI(true);
                startNewRecorder();
                updateStatus('æ­£åœ¨å½•éŸ³... æŒ‰ F9 æˆªå–', 'recording');
            } catch (err) {
                updateStatus(`æ— æ³•è®¿é—®éº¦å…‹é£: ${err.message}`, 'error');
                isSessionActive = false;
            }
        }

        function stopSession() {
            if (!isSessionActive) return;
            isSessionActive = false;
            isPaused = false;
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.onstop = null;
                mediaRecorder.stop();
            }
            if (stream) stream.getTracks().forEach(track => track.stop());
            updateSessionUI(false);
            updateStatus('ä¼šè¯å·²åœæ­¢', 'info');
        }

        function togglePause() {
            if (!isSessionActive) return;
            isPaused = !isPaused;
            if (isPaused) {
                mediaRecorder.pause();
                pauseBtn.textContent = 'ç»§ç»­';
                captureBtn.disabled = true;
                updateStatus('å·²æš‚åœ', 'paused');
            } else {
                mediaRecorder.resume();
                pauseBtn.textContent = 'æš‚åœ';
                captureBtn.disabled = false;
                updateStatus('æ­£åœ¨å½•éŸ³... æŒ‰ F9 æˆªå–', 'recording');
            }
        }

        function handleKeyDown(event) {
            if (event.key === 'F9' && isSessionActive && !isPaused) {
                event.preventDefault();
                captureAndProcessSegment();
            }
        }

        function captureAndProcessSegment() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
            segmentCounter++;
            addPlaceholderRow(`segment-${segmentCounter}`);
            mediaRecorder.stop();
        }

        function startNewRecorder() {
            if (!stream || !isSessionActive) return;
            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                if (audioBlob.size > 0 && segmentCounter > 0) {
                    transcribeAudio(audioBlob, `segment-${segmentCounter}`);
                }
                if (isSessionActive) {
                    startNewRecorder();
                    if(isPaused) mediaRecorder.pause();
                }
            };
            mediaRecorder.start();
        }

        async function transcribeAudio(audioBlob, segmentId) {
            const apiKey = openaiApiKeyInput.value.trim();
            const model = transcriptionModelSelect.value;
            const formData = new FormData();
            formData.append('file', new File([audioBlob], "recording.webm", { type: "audio/webm" }));
            formData.append('model', model);
            try {
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}` },
                    body: formData
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error?.message || 'æœªçŸ¥ Whisper API é”™è¯¯');
                
                makeCellEditable(segmentId, data.text);
                correctAndPolishText(data.text, segmentId);
            } catch (error) {
                console.error("Whisper Error:", error);
                updateTableCell(segmentId, 1, `è½¬å½•å¤±è´¥: ${error.message}`, 'error');
                updateTableCell(segmentId, 2, '---', 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }
        
        async function callLLM(prompt) {
            const model = processingEngineSelect.value;
            if (model.startsWith('gemini')) {
                const apiKey = geminiApiKeyInput.value.trim();
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.candidates || data.candidates.length === 0) {
                     throw new Error(data.error?.message || 'Gemini API è¿”å›æ— æ•ˆå“åº”');
                }
                return data.candidates[0].content.parts[0].text;
            } else { // OpenAI models
                const apiKey = openaiApiKeyInput.value.trim();
                const API_URL = 'https://api.openai.com/v1/chat/completions';
                const payload = {
                    model: model,
                    messages: [{ role: "user", content: prompt }]
                };
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok || !data.choices || data.choices.length === 0) {
                    throw new Error(data.error?.message || 'OpenAI API è¿”å›æ— æ•ˆå“åº”');
                }
                return data.choices[0].message.content;
            }
        }

        async function correctAndPolishText(originalText, segmentId) {
            const prompt = `ä»¥ä¸‹æ˜¯ä¸€æ®µä½›æ•™è®²åº§çš„è¯­éŸ³è½¬å½•ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é”™åˆ«å­—å’Œè°éŸ³å­—ã€‚è¯·çº æ­£æ‰€æœ‰é”™åˆ«å­—å’Œè°éŸ³å­—ï¼Œä½¿ç”¨ç®€ä½“ï¼Œä½¿æ–‡æœ¬æµç•…ã€å‡†ç¡®ã€‚ä¸è¦æ·»åŠ ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ ‡ç­¾ã€‚\n\nåŸå§‹æ–‡æœ¬ï¼š\n"${originalText}"`;
            try {
                const polishedText = await callLLM(prompt);
                identifyAndHighlightChineseTerms(polishedText, segmentId);
            } catch (error) {
                console.error("Processing Error:", error);
                updateTableCell(segmentId, 2, `æ ¡æ­£å¤±è´¥: ${error.message}`, 'error');
                updateTableCell(segmentId, 3, '---', 'error');
            }
        }
        
        async function identifyAndHighlightChineseTerms(text, segmentId) {
            const prompt = `ä»ä»¥ä¸‹æ–‡æœ¬ä¸­ï¼Œè¯†åˆ«å‡ºä¸ä½›æ•™ä¿®è¡Œ(ä¿®è¯)ç›¸å…³çš„è¯è¯­ä»¥åŠä½›æ•™å­¦æœ¯æœ¯è¯­ã€‚è¯·ä»¥JSONæ•°ç»„çš„æ ¼å¼è¿”å›è¿™äº›è¯è¯­ï¼Œä¾‹å¦‚ï¼š["è¯è¯­ä¸€", "è¯è¯­äºŒ"]ã€‚å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¯·è¿”å›ç©ºæ•°ç»„ []ã€‚\n\næ–‡æœ¬ï¼š\n"${text}"`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = highlightText(text, terms);
                updateTableCell(segmentId, 2, highlightedHtml, 'success');
                translateText(text, terms, segmentId);
            } catch (error) {
                console.error("Chinese Term ID Error:", error);
                updateTableCell(segmentId, 2, text, 'success'); // Show unhighlighted text on error
                translateText(text, [], segmentId); // Proceed without terms
            }
        }

        async function translateText(textToTranslate, chineseTerms, segmentId) {
            const prompt = `è¯·å°†ä»¥ä¸‹ä¸­æ–‡æ–‡æœ¬ç›´æ¥ç¿»è¯‘æˆè‹±æ–‡ï¼Œä¸è¦å›å¤å…¶ä»–å†…å®¹ã€‚\n\nä¸­æ–‡æ–‡æœ¬ï¼š\n"${textToTranslate}"`;
            try {
                const translatedText = await callLLM(prompt);
                identifyAndHighlightEnglishTerms(translatedText, chineseTerms, segmentId);
            } catch (error) {
                console.error("Translation Error:", error);
                updateTableCell(segmentId, 3, `ç¿»è¯‘å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function identifyAndHighlightEnglishTerms(text, chineseTerms, segmentId) {
            if (chineseTerms.length === 0) {
                updateTableCell(segmentId, 3, text, 'success');
                return;
            }
            const prompt = `From the following English text, identify the academic Buddhist terms that correspond to the concepts in the provided Chinese list. Return the identified English terms as a JSON array, for example: ["Term 1", "Term 2"]. If none are found, return an empty array [].\n\nEnglish Text:\n"${text}"\n\nOriginal Chinese Terms for reference:\n${JSON.stringify(chineseTerms)}`;
            try {
                const rawResponse = await callLLM(prompt);
                const termsJson = extractJson(rawResponse);
                const terms = JSON.parse(termsJson);
                const highlightedHtml = highlightText(text, terms);
                updateTableCell(segmentId, 3, highlightedHtml, 'success');
            } catch (error) {
                console.error("English Term ID Error:", error);
                updateTableCell(segmentId, 3, text, 'success'); // Show unhighlighted text on error
            }
        }

        function extractJson(text) {
            const match = text.match(/```json\s*([\s\S]*?)\s*```/);
            if (match && match[1]) {
                return match[1].trim();
            }
            return text.trim();
        }

        function updateSessionUI(isActive) {
            sessionBtn.textContent = isActive ? 'åœæ­¢ä¼šè¯' : 'å¯åŠ¨ä¼šè¯';
            sessionBtn.classList.toggle('bg-blue-600', !isActive);
            sessionBtn.classList.toggle('hover:bg-blue-700', !isActive);
            sessionBtn.classList.toggle('bg-red-600', isActive);
            sessionBtn.classList.toggle('hover:bg-red-700', isActive);
            pauseBtn.disabled = !isActive;
            captureBtn.disabled = !isActive;
            pauseBtn.textContent = 'æš‚åœ';
            openaiApiKeyInput.disabled = isActive;
            geminiApiKeyInput.disabled = isActive;
            transcriptionModelSelect.disabled = isActive;
            processingEngineSelect.disabled = isActive;
        }
        
        function updateStatus(text, type = 'info') {
            statusText.textContent = text;
            statusIndicator.className = 'w-3 h-3 rounded-full mr-2';
            switch (type) {
                case 'recording': statusIndicator.classList.add('bg-green-500', 'status-dot'); break;
                case 'paused': statusIndicator.classList.add('bg-yellow-500'); break;
                case 'error': statusIndicator.classList.add('bg-red-500'); break;
                default: statusIndicator.classList.add('bg-gray-400');
            }
        }
        
        const loadingCellHtml = `<div class="flex items-center text-sm text-gray-500"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>å¤„ç†ä¸­...</div>`;

        function addPlaceholderRow(segmentId) {
            const row = resultsTableBody.insertRow(0);
            row.id = segmentId;
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${new Date().toLocaleTimeString()}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
                <td class="px-6 py-4 whitespace-pre-wrap">${loadingCellHtml}</td>
            `;
            scrollToTop();
        }

        function makeCellEditable(segmentId, text) {
            const row = document.getElementById(segmentId);
            if (!row) return;
            const cell = row.cells[1];
            
            const div = document.createElement('div');
            div.className = 'editable-cell';
            div.contentEditable = true;
            div.textContent = text;
            div.dataset.originalText = text;

            const finalizeEdit = () => {
                if (div.contentEditable !== 'true') return;

                div.contentEditable = false;
                div.classList.remove('editable-cell');
                document.removeEventListener('mousedown', handleDocumentClick, true);

                const newText = div.textContent;
                const originalText = div.dataset.originalText;

                if (newText !== originalText) {
                    updateTableCell(segmentId, 2, loadingCellHtml, 'loading');
                    updateTableCell(segmentId, 3, loadingCellHtml, 'loading');
                    correctAndPolishText(newText, segmentId);
                }
            };

            const handleDocumentClick = (event) => {
                if (!div.contains(event.target)) {
                    finalizeEdit();
                }
            };

            div.addEventListener('focus', () => {
                setTimeout(() => {
                    document.addEventListener('mousedown', handleDocumentClick, true);
                }, 0);
            });

            div.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    finalizeEdit();
                }
            });

            cell.innerHTML = '';
            cell.appendChild(div);
            div.focus();
        }

        function updateTableCell(segmentId, cellIndex, content, status) {
            const row = document.getElementById(segmentId);
            if (!row || !row.cells[cellIndex]) return;
            const cell = row.cells[cellIndex];

            if (status === 'loading') {
                cell.innerHTML = content;
            } else {
                cell.innerHTML = `<div class="text-sm ${status === 'success' ? 'text-gray-900' : 'text-red-600'}">${content}</div>`;
            }
        }

        function highlightText(text, terms) {
            if (!terms || terms.length === 0) return text;
            terms.sort((a, b) => b.length - a.length);
            const regex = new RegExp(`(${terms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'g');
            return text.replace(regex, `<span class="highlight">$1</span>`);
        }
        
        function scrollToTop() {
            tableContainer.scrollTop = 0;
        }
    </script>
</body>
</html>
